% -*- coding: utf-8 -*-
%-------------------------designed by zcf--------------
\documentclass[UTF8,a4paper,10pt]{ctexart}
\usepackage[left=3.17cm, right=3.17cm, top=2.74cm, bottom=2.74cm]{geometry}
\usepackage{amsmath}
\usepackage{graphicx,subfig}
\usepackage{float}
\usepackage{cite}
\usepackage{caption}
\usepackage{enumerate}
\usepackage{booktabs} %表格
\usepackage{multirow}
\usepackage{color}
\newcommand{\tabincell}[2]{\begin{tabular}{@{}#1@{}}#2\end{tabular}}  %表格强制换行
%-------------------------字体设置--------------
\usepackage{times} 
\newcommand{\yihao}{\fontsize{26pt}{36pt}\selectfont}           % 一号, 1.4 倍行距
\newcommand{\erhao}{\fontsize{22pt}{28pt}\selectfont}          % 二号, 1.25倍行距
\newcommand{\xiaoer}{\fontsize{18pt}{18pt}\selectfont}          % 小二, 单倍行距
\newcommand{\sanhao}{\fontsize{16pt}{24pt}\selectfont}  %三号字
\newcommand{\xiaosan}{\fontsize{15pt}{22pt}\selectfont}        % 小三, 1.5倍行距
\newcommand{\sihao}{\fontsize{14pt}{21pt}\selectfont}            % 四号, 1.5 倍行距
\newcommand{\banxiaosi}{\fontsize{13pt}{19.5pt}\selectfont}    % 半小四, 1.5倍行距
\newcommand{\xiaosi}{\fontsize{12pt}{18pt}\selectfont}            % 小四, 1.5倍行距
\newcommand{\dawuhao}{\fontsize{11pt}{11pt}\selectfont}       % 大五号, 单倍行距
\newcommand{\wuhao}{\fontsize{10.5pt}{15.75pt}\selectfont}    % 五号, 单倍行距
%-------------------------章节名----------------
\usepackage{ctexcap} 
\CTEXsetup[name={,、},number={ \chinese{section}}]{section}
\CTEXsetup[name={（,）},number={\chinese{subsection}}]{subsection}
\CTEXsetup[name={,.},number={\arabic{subsubsection}}]{subsubsection}
%-------------------------页眉页脚--------------
\usepackage{fancyhdr}
\pagestyle{fancy}
\lhead{\kaishu \leftmark}
% \chead{}
\rhead{\kaishu 计算机系统设计作业报告}%加粗\bfseries 
\lfoot{}
\cfoot{\thepage}
\rfoot{}
\renewcommand{\headrulewidth}{0.1pt}  
\renewcommand{\footrulewidth}{0pt}%去掉横线
\newcommand{\HRule}{\rule{\linewidth}{0.5mm}}%标题横线
\newcommand{\HRulegrossa}{\rule{\linewidth}{1.2mm}}
%-----------------------伪代码------------------
\usepackage{algorithm}  
\usepackage{algorithmicx}  
\usepackage{algpseudocode}  
\floatname{algorithm}{Algorithm}  
\renewcommand{\algorithmicrequire}{\textbf{Input:}}  
\renewcommand{\algorithmicensure}{\textbf{Output:}} 
\usepackage{lipsum}  
\makeatletter
\newenvironment{breakablealgorithm}
  {% \begin{breakablealgorithm}
  \begin{center}
     \refstepcounter{algorithm}% New algorithm
     \hrule height.8pt depth0pt \kern2pt% \@fs@pre for \@fs@ruled
     \renewcommand{\caption}[2][\relax]{% Make a new \caption
      {\raggedright\textbf{\ALG@name~\thealgorithm} ##2\par}%
      \ifx\relax##1\relax % #1 is \relax
         \addcontentsline{loa}{algorithm}{\protect\numberline{\thealgorithm}##2}%
      \else % #1 is not \relax
         \addcontentsline{loa}{algorithm}{\protect\numberline{\thealgorithm}##1}%
      \fi
      \kern2pt\hrule\kern2pt
     }
  }{% \end{breakablealgorithm}
     \kern2pt\hrule\relax% \@fs@post for \@fs@ruled
  \end{center}
  }
\makeatother
%------------------------代码-------------------
\usepackage{xcolor} 
\usepackage{listings} 
\usepackage{fontspec}
\newfontfamily\menlo{Menlo}
\setmonofont[Mapping={}]{Monaco} 
\definecolor{mygreen}{rgb}{0,0.6,0}
\definecolor{mygray}{rgb}{0.5,0.5,0.5}
\definecolor{mymauve}{rgb}{0.58,0,0.82}
\lstset{ %
backgroundcolor=\color{white},   % choose the background color
basicstyle=\footnotesize\ttfamily,        % size of fonts used for the code
columns=fullflexible,
breaklines=true,                 % automatic line breaking only at whitespace
captionpos=b,                    % sets the caption-position to bottom
tabsize=4,
commentstyle=\color{mygreen},    % comment style
escapeinside={\%*}{*)},          % if you want to add LaTeX within your code
keywordstyle=\color{blue},       % keyword style
stringstyle=\color{mymauve}\ttfamily,     % string literal style
frame=single,
rulesepcolor=\color{red!20!green!20!blue!20},
numbers=left,
 numberstyle=\tiny\menlo
% identifierstyle=\color{red},
% language=c++,
}
%------------超链接----------
\usepackage[colorlinks,linkcolor=black,anchorcolor=blue]{hyperref}
%------------------------TODO-------------------
\usepackage{enumitem,amssymb}
\newlist{todolist}{itemize}{2}
\setlist[todolist]{label=$\square$}
% for check symbol 
\usepackage{pifont}
\newcommand{\cmark}{\ding{51}}%
\newcommand{\xmark}{\ding{55}}%
\newcommand{\done}{\rlap{$\square$}{\raisebox{2pt}{\large\hspace{1pt}\cmark}}\hspace{-2.5pt}}
\newcommand{\wontfix}{\rlap{$\square$}{\large\hspace{1pt}\xmark}}
%------------------------水印-------------------
\usepackage{tikz}
\usepackage{xcolor}
\usepackage{eso-pic}

\newcommand{\watermark}[3]{\AddToShipoutPictureBG{
\parbox[b][\paperheight]{\paperwidth}{
\vfill%
\centering%
\tikz[remember picture, overlay]%
  \node [rotate = #1, scale = #2] at (current page.center)%
    {\textcolor{gray!80!cyan!30!magenta!30}{#3}};
\vfill}}}



%———————————————————————————————————————————正文———————————————————————————————————————————————
%----------------------------------------------
\begin{document}
\begin{titlepage}
    \begin{center}
    \includegraphics[width=0.8\textwidth]{NKU.png}\\[1cm]    
    \textsc{\Huge \kaishu{\textbf{南\ \ \ \ \ \ 开\ \ \ \ \ \ 大\ \ \ \ \ \ 学}} }\\[0.9cm]
    \textsc{\huge \kaishu{\textbf{计\ \ 算\ \ 机\ \ 学\ \ 院}}}\\[0.5cm]
    \textsc{\Large \textbf{计算机系统设计}}\\[0.8cm]
    \HRule \\[0.9cm]
    { \LARGE \bfseries PA实验三报告}\\[0.4cm]
    \HRule \\[2.0cm]
    \centering
    \textsc{\LARGE \kaishu{朱浩泽\ 1911530}}\\[0.5cm]
    \textsc{\LARGE \kaishu{年级\ :\ 2019级}}\\[0.5cm]
    \textsc{\LARGE \kaishu{专业\ :\ 计算机科学与技术}}\\[0.5cm]
    \textsc{\LARGE \kaishu{指导教师\ :\ 卢冶}}\\[0.5cm]
    \vfill
    {\Large \today}
    \end{center}
\end{titlepage}
% -------------摘------要--------------
\newpage
\thispagestyle{empty}
% \renewcommand{\abstractname}{\kaishu \sihao \textbf{摘要}}
%     \begin{abstract}

%         \noindent  %顶格
%         \textbf{\\\ 关键字：Parallel}\textbf{} \\\ \\\
%     \end{abstract}
% % ----------------------------------------------------------------
\tableofcontents
% ----------------------------------------------------------------
\newpage
\watermark{60}{10}{NKU}
\setcounter{page}{1}
\section{概述}
\subsection{实验目的}
\begin{itemize}
  \item 理解操作系统概念
  \item 将机器底层和上层应用实现联系
  \item 了解操作系统中最常见的系统调用，并实现中断机制
  \item 了解文件系统的基本内容，实现简易文件系统
  
\end{itemize}
\subsection{实验内容}
实现一个简易的系统，主要实现系统的中断过程，尤其是系统调用，于此同时，实现文件系统（通过系统调用写入文件系统）。\textbf{在不听劝告的情况下使用
64位系统，折腾gcc以及各种环境问题，提升工程能力。}

\section{阶段一\ \ 加载操作系统的第一个用户程序}
\subsection{环境变量的修改}
首先，我们需要在NEMU上运行一个裁剪版本的Nanos操作系统，然后在这个操作系统上运行我们的程序。为了在Nanos上加载我们的可执行程序，我们需要更改app的编译路径，将navy-apps的makefile中的ISA路径指向x86，然后我们编译测试程序生成可执行文件，等待后续的加载。

\subsection{实现loader}
loader将ramdisk的内容移动到正确的内存位置0x4000000（通过navy-apps/Makefile.compile中的LDFLAGS 变量可以知道），将比特串放在正确的位置后可实现程序的运行。

修改nanos-lita/src/loader.c中的loader函数
\begin{lstlisting}[language = C++]
uintptr_t loader(_Protect *as, const char *filename) {
  // TODO();
  ramdisk_read(DEFAULT_ENTRY, 0, RAMDISK_SIZE);
  return (uintptr_t)DEFAULT_ENTRY;
}
\end{lstlisting}
\color{red}{此处出现了第一个离谱的bug，见bug总结/实现loader后出现段错误}
\normalcolor
\subsection{准备IDT}

在实现了建议的loader函数后，我们对dummy.c程序进行测试，结果发现有指令没有实现，通过查阅i386手册可以知道是int指令没有实现。但是，我们在实现int指令前，我们先要实现中断描述符表（IDT），因为实际的问题来源于调用中断信号0x80时使用了int指令。

\begin{center}
  \includegraphics*[scale = 0.3]{pic/1}
\end{center}

在IDT准备过程中，首先需要一个寄存器存放IDT的首地址和长度，所以我们引入了IDTR寄存器存放这些信息。该寄存器在nemu/include/cpu/reg.h中实现，代码如下：  
\begin{lstlisting}[language = C++]
struct IDTR
{
  /* data */
  uint32_t base;
  uint16_t limit; 
} idtr;
\end{lstlisting}

该寄存器会在\_asye\_init()函数中初始化设置idt的首地址和长度，传入对应的数据。

然后我们要实现lidt指令，该指令会将idtr的首地址和长度写入寄存器中，然后调用\_asm\_lidt()函数来实现IDT的设置。

然后我们需要实现lidt指令，将操作数信息从eax寄存器中读出。该指令首先还是需实现翻码函数lidt\_a，该译码函数在nemu/include/cpu/decode.h中进行注册，然后在nemu/src/decode/decode.c中进行实现
\begin{lstlisting}[language = C++]
make_DHelper(lidt_a) {
  decode_op_a(eip, id_dest, true);
}
\end{lstlisting}

然后我们在nemu/src/cpu/exec/all-instr.h中对lidt指令进行注册，并在nemu/src/cpu/exec/system.c中进行实现，将操作数信息从eax寄存器中读出。
\begin{lstlisting}[language = C++]
make_EHelper(lidt) {
  // TODO();
  t1 = id_dest -> val;
  rtl_lm(&t0, &t1, 2);
  cpu.idtr.limit = t0;

  t1 = id_dest -> val + 2;
  rtl_lm(&t0, &t1, 4);
  cpu.idtr.base = t0;

#ifdef DEBUG
  Log("idtr.limit=0x%x", cpu.idtr.limit);
  Log("idtr.base=0x%x", cpu.idtr.base);
#endif
  print_asm_template1(lidt);
}
\end{lstlisting}
最后我们在exec.c中进行optable的注册
\begin{lstlisting}[language = C++]
make_group(gp7,
  EMPTY, EMPTY, EMPTY, IDEX(lidt_a, lidt),
  EMPTY, EMPTY, EMPTY, EMPTY)
\end{lstlisting}

\subsection{cs寄存器的实现}
我们在nemu/include/cpu/reg.h文件中对cs寄存器进行初始化，将其放在cpu\_state中，并在
nemu/src/monitor/monitor.c中进行初始化，赋初值为8。
\subsection{int指令的实现}
在我们实现了IDT和cs寄存器后，我们在nemu/src/cpu/intr.c文件中的raise\_intr函数中模拟了异常出现后的硬件操作，具体过程就是寄存器压栈，根据索引取出IDT数组信息，处理结构
体信息得到跳转目标地址并设置跳转。
\begin{lstlisting}[language = C++]
void raise_intr(uint8_t NO, vaddr_t ret_addr) {
  /* TODO: Trigger an interrupt/exception with ``NO''.
   * That is, use ``NO'' to index the IDT.
   */

  // TODO();
  memcpy(&t1, &cpu.eflags, sizeof(cpu.eflags));
  rtl_li(&t0, t1);
  rtl_push(&t0);
  rtl_push(&cpu.cs);
  rtl_li(&t0, ret_addr);
  rtl_push(&t0);
  vaddr_t gate_addr = cpu.idtr.base + NO * sizeof(GateDesc);
  // Log("%d %d %d\n", gate_addr, cpu.idtr.base, cpu.idtr.limit);
  assert(gate_addr <= cpu.idtr.base + cpu.idtr.limit);

  uint32_t off_15_0 = vaddr_read(gate_addr,2);
  uint32_t off_32_16 = vaddr_read(gate_addr+sizeof(GateDesc)-2,2);
  uint32_t target_addr = (off_32_16 << 16) + off_15_0;
#ifdef DEBUG
  Log("target_addr=0x%x",target_addr);
#endif
  decoding.is_jmp = 1;
  decoding.jmp_eip = target_addr;
}
\end{lstlisting}
在这些都实现后，我们便可以着手进行int指令的实现。我们int执行函数的主体实现在了nemu/src/cpu/exec/system.c中，并在exe.c中对int指令进行了注册
\begin{lstlisting}[language = C++]
make_EHelper(int) {
    // TODO();
  
    uint8_t NO = id_dest -> val & 0xff;
    raise_intr(NO, decoding.seq_eip);
    print_asm("int %s", id_dest->str);
  
  #ifdef DIFF_TEST
    diff_test_skip_nemu();
  #endif
  }
\end{lstlisting}


\subsection{pusha和popa指令实现}
实现完int指令之后，本以为没问题行了，进行测试，结果发现仍然后invalid code。查阅i386手册，可以知道是pusha指令没有实现， 经过思考可以得知，popa指令一定也没有实现。查看手册的说明，pusha的作用是将所有的寄存器分别压栈和出栈。
\begin{center}
  \includegraphics*[scale= 0.7]{pic/截屏2022-05-16 00.07.42.png}
\end{center}
我们在nemu/src/cpu/exec/data-mov.c中实现pusha指令如下
\begin{lstlisting}[language = C++]
make_EHelper(pusha) {
  // TODO();
  t0 = cpu.esp;
  rtl_push(&cpu.eax);
  rtl_push(&cpu.ecx);
  rtl_push(&cpu.edx);
  rtl_push(&cpu.ebx);
  rtl_push(&t0);
  rtl_push(&cpu.ebp);
  rtl_push(&cpu.esi);
  rtl_push(&cpu.edi);

  print_asm("pusha");
}
\end{lstlisting}

popa的作用是将所有的寄存器分别出栈和压栈。
\begin{center}
  \includegraphics*[scale= 0.7]{pic/截屏2022-05-16 00.07.42.png}
\end{center}
我们在nemu/src/cpu/exec/data-mov.c中实现popa指令如下
\begin{lstlisting}[language = C++]
make_EHelper(popa) {
  // TODO();
  rtl_pop(&cpu.edi);
  rtl_pop(&cpu.esi);
  rtl_pop(&cpu.ebp);
  rtl_pop(&t0);
  rtl_pop(&cpu.ebx);
  rtl_pop(&cpu.edx);
  rtl_pop(&cpu.ecx);
  rtl_pop(&cpu.eax);
  print_asm("popa");
}
\end{lstlisting}

在这之后，我们需要重新组织TrapFrame（定义在nexus-am/am/arch/x86-nemu/include/arch.h的\_ResSet结构体中），使得这些
成员声明的顺序和 nexus-am/am/arch/x86-nemu/src/trap.S 中构造的trap frame保持一致。
\begin{lstlisting}[language = C++]
struct _RegSet {
  // uintptr_t esi, ebx, eax, eip, edx, error_code, eflags, ecx, cs, esp, edi, ebp;
  uintptr_t edi, esi, ebp, esp, ebx, edx, ecx, eax;
  int       irq;
  uintptr_t error_code;
  uintptr_t eip;
  uintptr_t cs;
  uintptr_t eflags;
};
\end{lstlisting}
\color{red}{在这里的时候，我们又出现了段错误的bug，见bug总结/HAS ASYE宏开启}
\normalcolor
\subsection{系统调用}
接下来，我们要实现系统调用。首先我们在nanos-lite/src/irq.c文件中的do\_event()函数中识别出系统调用事件 \_EVENT\_SYSCALL ，然后调用 do\_syscall()
\begin{lstlisting}[language = C++]
extern _RegSet* do_syscall(_RegSet *r);
static _RegSet* do_event(_Event e, _RegSet* r) {
  switch (e.event) {
    case _EVENT_SYSCALL:
      return do_syscall(r);
    default: panic("Unhandled event ID = %d", e.event);
  }
  return NULL;
}
\end{lstlisting}

在 nexus-am/am/arch/x86-nemu/include/arch.h 中实现正确的 SYSCALL\_ARGx() 宏，让它们从作为参数的现场 reg 中获得正确的系统调用参数寄存器(\_syscall\_()函数以及将系统调用的参数依次放入\%eax, \%ebx, \%ecx, \%edx 四个寄存器中)。
\begin{lstlisting}[language = C++]
#define SYSCALL_ARG1(r) r -> eax
#define SYSCALL_ARG2(r) r -> ebx
#define SYSCALL_ARG3(r) r -> ecx
#define SYSCALL_ARG4(r) r -> edx
\end{lstlisting}


在nanos-lite/src/syscall.c的SYS\_none函数中添加系统调用，设置系统调用的返回值。
\begin{lstlisting}[language = C++]
_RegSet* do_syscall(_RegSet *r) {
    uintptr_t a[4];
    a[0] = SYSCALL_ARG1(r);
    a[1] = SYSCALL_ARG2(r);
    a[2] = SYSCALL_ARG3(r);
    a[3] = SYSCALL_ARG4(r);
  
    switch (a[0]) {
      case SYS_none: 
        SYSCALL_ARG1(r) = sys_none();
        break;
      default: panic("Unhandled syscall ID = %d", a[0]);
    }
  
    return NULL;
  }
\end{lstlisting}


然后，我们还需要在nemu/src/cpu/exec/system.c中实现iret指令对现场进行恢复，其主要作用是从异常处理代码中返回，将栈顶的三个元素来依次解释成 EIP、CS、EFLAGS，并恢复。用户进程可以通过 \%eax 寄存器获得系统调用的返回值，进而得知系统调用执行的结果。
\begin{lstlisting}[language = C++]
make_EHelper(iret) {
  // TODO();
  rtl_pop(&cpu.eip);
  rtl_pop(&cpu.cs);
  rtl_pop(&t0);
  memcpy(&cpu.eflags, &t0, sizeof(cpu.eflags));
  decoding.jmp_eip = 1;
  decoding.seq_eip = cpu.eip;
  print_asm("iret");
}
\end{lstlisting}

在这之后，我们在nanos-lite/src/syscall.c中实现 SYS\_exit 系统调用，其目的是接收一个退出状态的参数，用这个参数调用\_halt()即可。
\begin{lstlisting}[language = C++]
_RegSet* do_syscall(_RegSet *r) {
    uintptr_t a[4];
    a[0] = SYSCALL_ARG1(r);
    a[1] = SYSCALL_ARG2(r);
    a[2] = SYSCALL_ARG3(r);
    a[3] = SYSCALL_ARG4(r);
  
    switch (a[0]) {
      case SYS_none: 
        SYSCALL_ARG1(r) = sys_none();
        break;
      case SYS_exit: 
        sys_exit(a[1]);
        break;
      default: panic("Unhandled syscall ID = %d", a[0]);
    }
  
    return NULL;
  }  
\end{lstlisting}
\subsection{实验结果}
\begin{center}
  \includegraphics*[scale = 0.25]{pic/hah}
\end{center}





































































\section{bug总结}
这一部分，基本都是因为我们自己不听劝告，执意要使用64位系统，折腾gcc以及各种环境问题，导致了各种各样意想不到的问题。
\subsection{实现loader后出现段错误}
在我们最开始实现loader时，运行出现了段错误的问题，第一反应是肯定是代码书写有问题，心想坏了，这刚刚开始指定是以前代码的问题，顾花了一下午找之前代码中的问题，没找到，第一次破防。

然后想起来，可以查看反汇编代码，看出了端倪，生成了一堆没啥用的不知道是干啥的东西，导致程序过大越界了。意识到是因该是编译器的问题，上stackoverflow查找，在nano下的makefile 中加入如下参数，问题解决。
\begin{lstlisting}[language = bash]
OBJCOPY_FLAG = -S --remove-section .note.gnu.property --set-section-flags .bss=alloc,contents -O binary
\end{lstlisting}

\subsection{HAS ASYE宏开启}
在我们实现完popa和pusha并正确组织了trap frame之后，我们进行了运行测试，嘿嘿，出现了段错误。
\begin{center}
  \includegraphics*[scale = 0.3]{pic/报错2}
\end{center}
可以看到是因为gate\_addr的值大于了cpu.idtr.base + cpu.idtr.limit的值。我们利用Log进行输出，得到的结果比较出乎意料，cpu.idtr.base和cpu.idtr.limit的值都是0。总以为是哪里写错了，又从头到尾撸了一遍代码，没啥问题，最终发现是nanos-lite/src/main.c中的HAS ASY宏没打开，这意味着根本没有调用init\_irq()函数，也意味着没有调用位于 nexus-am/am/arch/x86-nemu/src/asye.c 中的\_asye\_init()函数，导致IDT根本都没初始化，加上了这个宏之后，错误解决。

























% \section{概述}
% %——————————————————————————————————————
% \subsection{第一节}
% 如图\ref{fig:1}所示
% \begin{figure}[H]
%     \centering
%     \includegraphics[scale=0.3]{NKU.png}
%     \caption{Caption}
%     \label{fig:1}
% \end{figure}

% 表
% \begin{table}[!htbp]
%   \centering
%   \begin{tabular}{ccccccccccc}
%   \toprule  
%   N/n$\backslash$Algo& naive-conv& naive-pool& omp-conv& omp-pool\\
%   \midrule
%   64/2& 0.0167& 0.01255& 0.04142& 0.03799\\
%   64/4& 0.03599&0.0394& 0.0458& 0.0421\\
%   \bottomrule
%   \end{tabular}
%   \caption{性能测试结果(4线程)(单位:ms)}
% \end{table}

% 带单元格表格
% \begin{table}[!htbp]
%   \centering
%   \begin{tabular}{|c|c|c|c|c|c|c|}
%   \hline
%   \multicolumn{2}{|c|}{ \multirow{2}*{$Cost$} }& \multicolumn{5}{c|}{To}\\
%   \cline{3-7}
%   \multicolumn{2}{|c|}{}&$A$&$B$&$C$&$D$&$E$\\
%   \hline
%   \multirow{3}*{From}&$B$&7&0&1&3&8\\
%   \cline{2-7}
%   &$C$&8&1&0&2&7\\
%   \cline{2-7}
%   &$D$&8&3&2&0&5\\
%   \hline
%   \end{tabular}
%   \caption{结点C距离向量表(无毒性逆转)}
% \end{table}

% %——————————————————————————————————————
% \subsection{第二节}
% 伪代码

% \begin{breakablealgorithm} 
%   \caption{初始化obj文件信息——对应MeshSimplify类中readfile函数,Face类calMatrix函数} 
%   \begin{algorithmic}[1] %每行显示行号  
%       \Require obj文件,顶点、边、面列表
%       \Ensure 是否读取成功
%       \Function {calMatrix}{$Face$}  
%               \State $normal \gets e1×e2$  
%               \State $normal \gets normal/normal.length$
%               \State $temp[] \gets {normal.x, normal.y, normal.z, normal· Face.v1}$
%               \State $Matrix[i][j]=temp[i] * temp[j]$ 
%               \State \Return{$Matrix$}  
%       \EndFunction
%       \State 根据obj的v和f区分点面信息,读取并加入列表
%       \State $scale \gets $记录点坐标中距离原点最远的分量,以便后续OpenGL进行显示
%       \State $ori \gets $记录中心点,便于OpenGL显示在中心位置,避免有的obj偏移原点较多
%       \State 根据三角面片信息,计算一个面的三条边
%       \State 计算每个面的矩阵$\gets calMatrix$
%       \State 将每个面的矩阵加到各点,由点维护\\
%       \Return True
%   \end{algorithmic}  
% \end{breakablealgorithm}

% 代码
% \begin{lstlisting}[title=逐列访问平凡算法,frame=trbl,language={C++}]
%   void ord()   
%   {
%       double head,tail,freq,head1,tail1,timess=0; // timers
%       init(N);
%       QueryPerformanceFrequency((LARGE_INTEGER *)&freq );
%       QueryPerformanceCounter((LARGE_INTEGER *)&head);
%       for (int i=0; i<NN; i++)
%           for (int j=0; j<NN; j++)
%               col_sum[i] += (b[j][i]*a[j]);
%       QueryPerformanceCounter ((LARGE_INTEGER *)& tail) ;
%       cout << "\nordCol" <<(tail-head)*1000.0 / freq<< "ms" << endl;
%   }
% \end{lstlisting}


% %——————————————————————————————————————
% \subsection{第三节}

% 参考文献\cite{adams1995hitchhiker}\cite{shin2016deep}
    
% 多行公式
% \begin{align}
%   a+b = a + b \\
%   \frac{a+b}{a-b}
% \end{align}

% 行内公式：$\sum^N_{i=1}$

% \textbf{超链接}  \href{http://youtube.com/}{YouTube}

% 带标号枚举
% \begin{enumerate}
%   \item 1
%   \item 2
% \end{enumerate}

% 不带标号枚举
% \begin{itemize}
%   \item 1
%   \item 2
% \end{itemize}

% \xiaosi{切换字体大小}

% %----------------------------------------------------------------
% \section{总结}

% %----------------------------------------------------------------

\end{document}
