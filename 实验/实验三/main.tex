% -*- coding: utf-8 -*-
%-------------------------designed by zcf--------------
\documentclass[UTF8,a4paper,10pt]{ctexart}
\usepackage[left=3.17cm, right=3.17cm, top=2.74cm, bottom=2.74cm]{geometry}
\usepackage{amsmath}
\usepackage{graphicx,subfig}
\usepackage{float}
\usepackage{cite}
\usepackage{caption}
\usepackage{enumerate}
\usepackage{booktabs} %表格
\usepackage{multirow}
\usepackage{color}
\newcommand{\tabincell}[2]{\begin{tabular}{@{}#1@{}}#2\end{tabular}}  %表格强制换行
%-------------------------字体设置--------------
\usepackage{times} 
\newcommand{\yihao}{\fontsize{26pt}{36pt}\selectfont}           % 一号, 1.4 倍行距
\newcommand{\erhao}{\fontsize{22pt}{28pt}\selectfont}          % 二号, 1.25倍行距
\newcommand{\xiaoer}{\fontsize{18pt}{18pt}\selectfont}          % 小二, 单倍行距
\newcommand{\sanhao}{\fontsize{16pt}{24pt}\selectfont}  %三号字
\newcommand{\xiaosan}{\fontsize{15pt}{22pt}\selectfont}        % 小三, 1.5倍行距
\newcommand{\sihao}{\fontsize{14pt}{21pt}\selectfont}            % 四号, 1.5 倍行距
\newcommand{\banxiaosi}{\fontsize{13pt}{19.5pt}\selectfont}    % 半小四, 1.5倍行距
\newcommand{\xiaosi}{\fontsize{12pt}{18pt}\selectfont}            % 小四, 1.5倍行距
\newcommand{\dawuhao}{\fontsize{11pt}{11pt}\selectfont}       % 大五号, 单倍行距
\newcommand{\wuhao}{\fontsize{10.5pt}{15.75pt}\selectfont}    % 五号, 单倍行距
%-------------------------章节名----------------
\usepackage{ctexcap} 
\CTEXsetup[name={,、},number={ \chinese{section}}]{section}
\CTEXsetup[name={（,）},number={\chinese{subsection}}]{subsection}
\CTEXsetup[name={,.},number={\arabic{subsubsection}}]{subsubsection}
%-------------------------页眉页脚--------------
\usepackage{fancyhdr}
\pagestyle{fancy}
\lhead{\kaishu \leftmark}
% \chead{}
\rhead{\kaishu 计算机系统设计作业报告}%加粗\bfseries 
\lfoot{}
\cfoot{\thepage}
\rfoot{}
\renewcommand{\headrulewidth}{0.1pt}  
\renewcommand{\footrulewidth}{0pt}%去掉横线
\newcommand{\HRule}{\rule{\linewidth}{0.5mm}}%标题横线
\newcommand{\HRulegrossa}{\rule{\linewidth}{1.2mm}}
%-----------------------伪代码------------------
\usepackage{algorithm}  
\usepackage{algorithmicx}  
\usepackage{algpseudocode}  
\floatname{algorithm}{Algorithm}  
\renewcommand{\algorithmicrequire}{\textbf{Input:}}  
\renewcommand{\algorithmicensure}{\textbf{Output:}} 
\usepackage{lipsum}  
\makeatletter
\newenvironment{breakablealgorithm}
  {% \begin{breakablealgorithm}
  \begin{center}
     \refstepcounter{algorithm}% New algorithm
     \hrule height.8pt depth0pt \kern2pt% \@fs@pre for \@fs@ruled
     \renewcommand{\caption}[2][\relax]{% Make a new \caption
      {\raggedright\textbf{\ALG@name~\thealgorithm} ##2\par}%
      \ifx\relax##1\relax % #1 is \relax
         \addcontentsline{loa}{algorithm}{\protect\numberline{\thealgorithm}##2}%
      \else % #1 is not \relax
         \addcontentsline{loa}{algorithm}{\protect\numberline{\thealgorithm}##1}%
      \fi
      \kern2pt\hrule\kern2pt
     }
  }{% \end{breakablealgorithm}
     \kern2pt\hrule\relax% \@fs@post for \@fs@ruled
  \end{center}
  }
\makeatother
%------------------------代码-------------------
\usepackage{xcolor} 
\usepackage{listings} 
\usepackage{fontspec}
\newfontfamily\menlo{Menlo}
\setmonofont[Mapping={}]{Monaco} 
\definecolor{mygreen}{rgb}{0,0.6,0}
\definecolor{mygray}{rgb}{0.5,0.5,0.5}
\definecolor{mymauve}{rgb}{0.58,0,0.82}
\lstset{ %
backgroundcolor=\color{white},   % choose the background color
basicstyle=\footnotesize\ttfamily,        % size of fonts used for the code
columns=fullflexible,
breaklines=true,                 % automatic line breaking only at whitespace
captionpos=b,                    % sets the caption-position to bottom
tabsize=4,
commentstyle=\color{mygreen},    % comment style
escapeinside={\%*}{*)},          % if you want to add LaTeX within your code
keywordstyle=\color{blue},       % keyword style
stringstyle=\color{mymauve}\ttfamily,     % string literal style
frame=single,
rulesepcolor=\color{red!20!green!20!blue!20},
numbers=left,
 numberstyle=\tiny\menlo
% identifierstyle=\color{red},
% language=c++,
}
%------------超链接----------
\usepackage[colorlinks,linkcolor=black,anchorcolor=blue]{hyperref}
%------------------------TODO-------------------
\usepackage{enumitem,amssymb}
\newlist{todolist}{itemize}{2}
\setlist[todolist]{label=$\square$}
% for check symbol 
\usepackage{pifont}
\newcommand{\cmark}{\ding{51}}%
\newcommand{\xmark}{\ding{55}}%
\newcommand{\done}{\rlap{$\square$}{\raisebox{2pt}{\large\hspace{1pt}\cmark}}\hspace{-2.5pt}}
\newcommand{\wontfix}{\rlap{$\square$}{\large\hspace{1pt}\xmark}}
%------------------------水印-------------------
\usepackage{tikz}
\usepackage{xcolor}
\usepackage{eso-pic}

\newcommand{\watermark}[3]{\AddToShipoutPictureBG{
\parbox[b][\paperheight]{\paperwidth}{
\vfill%
\centering%
\tikz[remember picture, overlay]%
  \node [rotate = #1, scale = #2] at (current page.center)%
    {\textcolor{gray!80!cyan!30!magenta!30}{#3}};
\vfill}}}



%———————————————————————————————————————————正文———————————————————————————————————————————————
%----------------------------------------------
\begin{document}
\begin{titlepage}
    \begin{center}
    \includegraphics[width=0.8\textwidth]{NKU.png}\\[1cm]    
    \textsc{\Huge \kaishu{\textbf{南\ \ \ \ \ \ 开\ \ \ \ \ \ 大\ \ \ \ \ \ 学}} }\\[0.9cm]
    \textsc{\huge \kaishu{\textbf{计\ \ 算\ \ 机\ \ 学\ \ 院}}}\\[0.5cm]
    \textsc{\Large \textbf{计算机系统设计}}\\[0.8cm]
    \HRule \\[0.9cm]
    { \LARGE \bfseries PA实验三报告}\\[0.4cm]
    \HRule \\[2.0cm]
    \centering
    \textsc{\LARGE \kaishu{朱浩泽\ 1911530}}\\[0.5cm]
    \textsc{\LARGE \kaishu{年级\ :\ 2019级}}\\[0.5cm]
    \textsc{\LARGE \kaishu{专业\ :\ 计算机科学与技术}}\\[0.5cm]
    \textsc{\LARGE \kaishu{指导教师\ :\ 卢冶}}\\[0.5cm]
    \vfill
    {\Large \today}
    \end{center}
\end{titlepage}
% -------------摘------要--------------
\newpage
\thispagestyle{empty}
% \renewcommand{\abstractname}{\kaishu \sihao \textbf{摘要}}
%     \begin{abstract}

%         \noindent  %顶格
%         \textbf{\\\ 关键字：Parallel}\textbf{} \\\ \\\
%     \end{abstract}
% % ----------------------------------------------------------------
\tableofcontents
% ----------------------------------------------------------------
\newpage
\watermark{60}{10}{NKU}
\setcounter{page}{1}
\section{概述}
\subsection{实验目的}
\begin{itemize}
  \item 理解操作系统概念
  \item 将机器底层和上层应用实现联系
  \item 了解操作系统中最常见的系统调用，并实现中断机制
  \item 了解文件系统的基本内容，实现简易文件系统
  
\end{itemize}
\subsection{实验内容}
实现一个简易的系统，主要实现系统的中断过程，尤其是系统调用，于此同时，实现文件系统（通过系统调用写入文件系统）。\textbf{在不听劝告的情况下使用
64位系统，折腾gcc以及各种环境问题，提升工程能力。}

\section{阶段一\ \ 加载操作系统的第一个用户程序}
\subsection{环境变量的修改}
首先，我们需要在NEMU上运行一个裁剪版本的Nanos操作系统，然后在这个操作系统上运行我们的程序。为了在Nanos上加载我们的可执行程序，我们需要更改app的编译路径，将navy-apps的makefile中的ISA路径指向x86，然后我们编译测试程序生成可执行文件，等待后续的加载。

\subsection{实现loader}
loader将ramdisk的内容移动到正确的内存位置0x4000000（通过navy-apps/Makefile.compile中的LDFLAGS 变量可以知道），将比特串放在正确的位置后可实现程序的运行。

修改nanos-lita/src/loader.c中的loader函数
\begin{lstlisting}[language = C++]
uintptr_t loader(_Protect *as, const char *filename) {
  // TODO();
  ramdisk_read(DEFAULT_ENTRY, 0, RAMDISK_SIZE);
  return (uintptr_t)DEFAULT_ENTRY;
}
\end{lstlisting}
\color{red}{此处出现了第一个离谱的bug，见bug总结/实现loader后出现段错误}
\normalcolor
\subsection{准备IDT}

在实现了建议的loader函数后，我们对dummy.c程序进行测试，结果发现有指令没有实现，通过查阅i386手册可以知道是int指令没有实现。但是，我们在实现int指令前，我们先要实现中断描述符表（IDT），因为实际的问题来源于调用中断信号0x80时使用了int指令。

\begin{center}
  \includegraphics*[scale = 0.3]{pic/1}
\end{center}

在IDT准备过程中，首先需要一个寄存器存放IDT的首地址和长度，所以我们引入了IDTR寄存器存放这些信息。该寄存器在nemu/include/cpu/reg.h中实现，代码如下：  
\begin{lstlisting}[language = C++]
struct IDTR
{
  /* data */
  uint32_t base;
  uint16_t limit; 
} idtr;
\end{lstlisting}

该寄存器会在\_asye\_init()函数中初始化设置idt的首地址和长度，传入对应的数据。

然后我们要实现lidt指令，该指令会将idtr的首地址和长度写入寄存器中，然后调用\_asm\_lidt()函数来实现IDT的设置。

然后我们需要实现lidt指令，将操作数信息从eax寄存器中读出。该指令首先还是需实现翻码函数lidt\_a，该译码函数在nemu/include/cpu/decode.h中进行注册，然后在nemu/src/decode/decode.c中进行实现
\begin{lstlisting}[language = C++]
make_DHelper(lidt_a) {
  decode_op_a(eip, id_dest, true);
}
\end{lstlisting}

然后我们在nemu/src/cpu/exec/all-instr.h中对lidt指令进行注册，并在nemu/src/cpu/exec/system.c中进行实现，将操作数信息从eax寄存器中读出。
\begin{lstlisting}[language = C++]
make_EHelper(lidt) {
  // TODO();
  t1 = id_dest -> val;
  rtl_lm(&t0, &t1, 2);
  cpu.idtr.limit = t0;

  t1 = id_dest -> val + 2;
  rtl_lm(&t0, &t1, 4);
  cpu.idtr.base = t0;

#ifdef DEBUG
  Log("idtr.limit=0x%x", cpu.idtr.limit);
  Log("idtr.base=0x%x", cpu.idtr.base);
#endif
  print_asm_template1(lidt);
}
\end{lstlisting}
最后我们在exec.c中进行optable的注册
\begin{lstlisting}[language = C++]
make_group(gp7,
  EMPTY, EMPTY, EMPTY, IDEX(lidt_a, lidt),
  EMPTY, EMPTY, EMPTY, EMPTY)
\end{lstlisting}

\subsection{cs寄存器的实现}
我们在nemu/include/cpu/reg.h文件中对cs寄存器进行初始化，将其放在cpu\_state中，并在
nemu/src/monitor/monitor.c中进行初始化，赋初值为8。
\subsection{int指令的实现}
在我们实现了IDT和cs寄存器后，我们在nemu/src/cpu/intr.c文件中的raise\_intr函数中模拟了异常出现后的硬件操作，具体过程就是寄存器压栈，根据索引取出IDT数组信息，处理结构
体信息得到跳转目标地址并设置跳转。
\begin{lstlisting}[language = C++]
void raise_intr(uint8_t NO, vaddr_t ret_addr) {
  /* TODO: Trigger an interrupt/exception with ``NO''.
   * That is, use ``NO'' to index the IDT.
   */

  // TODO();
  memcpy(&t1, &cpu.eflags, sizeof(cpu.eflags));
  rtl_li(&t0, t1);
  rtl_push(&t0);
  rtl_push(&cpu.cs);
  rtl_li(&t0, ret_addr);
  rtl_push(&t0);
  vaddr_t gate_addr = cpu.idtr.base + NO * sizeof(GateDesc);
  // Log("%d %d %d\n", gate_addr, cpu.idtr.base, cpu.idtr.limit);
  assert(gate_addr <= cpu.idtr.base + cpu.idtr.limit);

  uint32_t off_15_0 = vaddr_read(gate_addr,2);
  uint32_t off_32_16 = vaddr_read(gate_addr+sizeof(GateDesc)-2,2);
  uint32_t target_addr = (off_32_16 << 16) + off_15_0;
#ifdef DEBUG
  Log("target_addr=0x%x",target_addr);
#endif
  decoding.is_jmp = 1;
  decoding.jmp_eip = target_addr;
}
\end{lstlisting}
在这些都实现后，我们便可以着手进行int指令的实现。我们int执行函数的主体实现在了nemu/src/cpu/exec/system.c中，并在exe.c中对int指令进行了注册
\begin{lstlisting}[language = C++]
make_EHelper(int) {
    // TODO();
  
    uint8_t NO = id_dest -> val & 0xff;
    raise_intr(NO, decoding.seq_eip);
    print_asm("int %s", id_dest->str);
  
  #ifdef DIFF_TEST
    diff_test_skip_nemu();
  #endif
  }
\end{lstlisting}


\subsection{pusha和popa指令实现}
实现完int指令之后，本以为没问题行了，进行测试，结果发现仍然后invalid code。查阅i386手册，可以知道是pusha指令没有实现， 经过思考可以得知，popa指令一定也没有实现。查看手册的说明，pusha的作用是将所有的寄存器分别压栈和出栈。
\begin{center}
  \includegraphics*[scale= 0.7]{pic/截屏2022-05-16 00.07.42.png}
\end{center}
我们在nemu/src/cpu/exec/data-mov.c中实现pusha指令如下
\begin{lstlisting}[language = C++]
make_EHelper(pusha) {
  // TODO();
  t0 = cpu.esp;
  rtl_push(&cpu.eax);
  rtl_push(&cpu.ecx);
  rtl_push(&cpu.edx);
  rtl_push(&cpu.ebx);
  rtl_push(&t0);
  rtl_push(&cpu.ebp);
  rtl_push(&cpu.esi);
  rtl_push(&cpu.edi);

  print_asm("pusha");
}
\end{lstlisting}

popa的作用是将所有的寄存器分别出栈和压栈。
\begin{center}
  \includegraphics*[scale= 0.7]{pic/截屏2022-05-16 00.07.42.png}
\end{center}
我们在nemu/src/cpu/exec/data-mov.c中实现popa指令如下
\begin{lstlisting}[language = C++]
make_EHelper(popa) {
  // TODO();
  rtl_pop(&cpu.edi);
  rtl_pop(&cpu.esi);
  rtl_pop(&cpu.ebp);
  rtl_pop(&t0);
  rtl_pop(&cpu.ebx);
  rtl_pop(&cpu.edx);
  rtl_pop(&cpu.ecx);
  rtl_pop(&cpu.eax);
  print_asm("popa");
}
\end{lstlisting}

在这之后，我们需要重新组织TrapFrame（定义在nexus-am/am/arch/x86-nemu/include/arch.h的\_ResSet结构体中），使得这些
成员声明的顺序和 nexus-am/am/arch/x86-nemu/src/trap.S 中构造的trap frame保持一致。
\begin{lstlisting}[language = C++]
struct _RegSet {
  // uintptr_t esi, ebx, eax, eip, edx, error_code, eflags, ecx, cs, esp, edi, ebp;
  uintptr_t edi, esi, ebp, esp, ebx, edx, ecx, eax;
  int       irq;
  uintptr_t error_code;
  uintptr_t eip;
  uintptr_t cs;
  uintptr_t eflags;
};
\end{lstlisting}
\color{red}{在这里的时候，我们又出现了段错误的bug，见bug总结/HAS ASYE宏开启}
\normalcolor
\subsection{系统调用}
接下来，我们要实现系统调用。首先我们在nanos-lite/src/irq.c文件中的do\_event()函数中识别出系统调用事件 \_EVENT\_SYSCALL ，然后调用 do\_syscall()
\begin{lstlisting}[language = C++]
extern _RegSet* do_syscall(_RegSet *r);
static _RegSet* do_event(_Event e, _RegSet* r) {
  switch (e.event) {
    case _EVENT_SYSCALL:
      return do_syscall(r);
    default: panic("Unhandled event ID = %d", e.event);
  }
  return NULL;
}
\end{lstlisting}

在 nexus-am/am/arch/x86-nemu/include/arch.h 中实现正确的 SYSCALL\_ARGx() 宏，让它们从作为参数的现场 reg 中获得正确的系统调用参数寄存器(\_syscall\_()函数以及将系统调用的参数依次放入\%eax, \%ebx, \%ecx, \%edx 四个寄存器中)。
\begin{lstlisting}[language = C++]
#define SYSCALL_ARG1(r) r -> eax
#define SYSCALL_ARG2(r) r -> ebx
#define SYSCALL_ARG3(r) r -> ecx
#define SYSCALL_ARG4(r) r -> edx
\end{lstlisting}


在nanos-lite/src/syscall.c的SYS\_none函数中添加系统调用，设置系统调用的返回值。
\begin{lstlisting}[language = C++]
_RegSet* do_syscall(_RegSet *r) {
    uintptr_t a[4];
    a[0] = SYSCALL_ARG1(r);
    a[1] = SYSCALL_ARG2(r);
    a[2] = SYSCALL_ARG3(r);
    a[3] = SYSCALL_ARG4(r);
  
    switch (a[0]) {
      case SYS_none: 
        SYSCALL_ARG1(r) = sys_none();
        break;
      default: panic("Unhandled syscall ID = %d", a[0]);
    }
  
    return NULL;
  }
\end{lstlisting}


然后，我们还需要在nemu/src/cpu/exec/system.c中实现iret指令对现场进行恢复，其主要作用是从异常处理代码中返回，将栈顶的三个元素来依次解释成 EIP、CS、EFLAGS，并恢复。用户进程可以通过 \%eax 寄存器获得系统调用的返回值，进而得知系统调用执行的结果。
\begin{lstlisting}[language = C++]
make_EHelper(iret) {
  // TODO();
  rtl_pop(&cpu.eip);
  rtl_pop(&cpu.cs);
  rtl_pop(&t0);
  memcpy(&cpu.eflags, &t0, sizeof(cpu.eflags));
  decoding.jmp_eip = 1;
  decoding.seq_eip = cpu.eip;
  print_asm("iret");
}
\end{lstlisting}

在这之后，我们在nanos-lite/src/syscall.c中实现 SYS\_exit 系统调用，其目的是接收一个退出状态的参数，用这个参数调用\_halt()即可。
\begin{lstlisting}[language = C++]
_RegSet* do_syscall(_RegSet *r) {
    uintptr_t a[4];
    a[0] = SYSCALL_ARG1(r);
    a[1] = SYSCALL_ARG2(r);
    a[2] = SYSCALL_ARG3(r);
    a[3] = SYSCALL_ARG4(r);
  
    switch (a[0]) {
      case SYS_none: 
        SYSCALL_ARG1(r) = sys_none();
        break;
      case SYS_exit: 
        sys_exit(a[1]);
        break;
      default: panic("Unhandled syscall ID = %d", a[0]);
    }
  
    return NULL;
  }  
\end{lstlisting}
\subsection{实验结果}
\begin{center}
  \includegraphics*[scale = 0.25]{pic/hah}
\end{center}


\section{阶段二 \ \ 
在操作系统上运行 Hello World}
在这一阶段，我们要在这一阶段运行hello world的循环打印程序。为实现这一目的，我们需要添加标准输出和堆区管理功能，并实现一个简易的文件系统。
\subsection{sys\_write系统调用的实现}
我们首先实现一个辅助函数\_write，其通过调用\_sys\_call函数返回eax寄存器的值。该函数在navy-apps/libs/libos/src/nanos.c文件中实现
\begin{lstlisting}[language = C++]
int _write(int fd, void *buf, size_t count){
    return _syscall_(SYS_write, fd, (uintptr_t)buf, count);
}
\end{lstlisting}
在nanos-lite/src/syscall.c中的do\_syscall 函数中加入SYS\_write系统调用，其实现如下：
\begin{lstlisting}[language = C++]
_RegSet* do_syscall(_RegSet *r) {
  uintptr_t a[4];
  a[0] = SYSCALL_ARG1(r);
  a[1] = SYSCALL_ARG2(r);
  a[2] = SYSCALL_ARG3(r);
  a[3] = SYSCALL_ARG4(r);

  switch (a[0]) {
    case SYS_none: 
      SYSCALL_ARG1(r) = sys_none();
      break;
    case SYS_exit: 
      sys_exit(a[1]);
      break;
    case SYS_write:
      SYSCALL_ARG1(r) = sys_write(a[1], (void*)a[2], a[3]);
      break; 
    default: panic("Unhandled syscall ID = %d", a[0]);
  }

  return NULL;
}
\end{lstlisting}
在nanos-lite/src/syscall.c中实现sys\_write系统调用的实现
\begin{lstlisting}[language = C++]
int sys_write(int fd, void *buf, size_t len) {
	if(fd == 1 || fd == 2) {
		char c;
    // Log("buffer:%s", (char*)buf);
		for(int i = 0; i < len; i++) {
			memcpy(&c ,buf + i, 1);
			_putc(c);
		}
		return len;
	}
  else {
     panic("Unhandled fd=%d in sys_write()", fd);
  }
  return -1;
}
\end{lstlisting}
\subsection{堆区管理}
在我们没有实现堆区的时候，在sys\_write函数中通过Log查看write的调用的情况的时候发现通过printf输出的时候是逐个字符输出的。

我们知道调整堆区大小是通过 \_sbrk库函数来实现的，它的功能是将用户程序的的数据段结束的位置增长increment字节来实现。 


首先我们在nanos-lite/src/syscall.c中实现sys\_brk系统调用的实现，目前 Nanos-
lite 为单任务 OS，用户程序可自由使用空闲的内存，所以让 SYS\_brk 总是返回0，表示堆区大小的调整总是成功。
\begin{lstlisting}[language = C++]
_RegSet* do_syscall(_RegSet *r) {
    uintptr_t a[4];
    a[0] = SYSCALL_ARG1(r);
    a[1] = SYSCALL_ARG2(r);
    a[2] = SYSCALL_ARG3(r);
    a[3] = SYSCALL_ARG4(r);
  
    switch (a[0]) {
      case SYS_none: 
        SYSCALL_ARG1(r) = sys_none();
        break;
      case SYS_exit: 
        sys_exit(a[1]);
        break;
      case SYS_write:
        SYSCALL_ARG1(r) = sys_write(a[1], (void*)a[2], a[3]);
        break;
      case SYS_brk:
        SYSCALL_ARG1(r) = sys_brk(a[1]);
        break;
      default: panic("Unhandled syscall ID = %d", a[0]);
  }
  return -1;
}

int sys_brk(int addr) {
  return 0;
}
\end{lstlisting}

然后我们在用户层实现\_sbrk()，其主要思路是
program break 一开始的位置位于程序的数据段结束的位置（由\_end标志），根据记录的 program break 位置和参数 increment，计算出新 program break，通过 SYS\_brk 系统调用来让操作系统设置新的program break，若成功返回0，更新 program break 的位置， 并将旧 program break 的位置作为\_sbrk的返回值返回；若失败\_sbrk返回-1。在navy-apps/libs/libos/src/nanos.c当中完成代码如下:
\begin{lstlisting}[language = C++]
void *_sbrk(intptr_t increment){
  extern int end;
  static uintptr_t probreak = (uintptr_t)&end;
  uintptr_t probreak_new = probreak + increment;
  int r = _syscall_(SYS_brk, probreak_new, 0, 0);
  if(r == 0) {
    uintptr_t temp = probreak;
    probreak = probreak_new;
    return (void*)temp;
  }
  return (void *)-1;
}
\end{lstlisting}
实现后，我们可以看到，打印的内容不在时一个一个蹦出来的了，是连续的
\begin{center}
  \includegraphics*[scale = 0.35]{pic/4}
\end{center}

\color{red}{这一部分，我们又遇到了一个离谱的错误，见bug记录/CS指令}
\normalcolor
\subsection{简易文件系统的实现}
我们大多数的app都是具有信息记录的，而且，文件的数量增加之后,我们就要知道哪个文件在 ramdisk 的什么位置。所以我们的操作系统需要实现简易的文件系统。

我们在nanos-lite/include/fs.h中注册我们需要的函数，并在nanos-lite/src/fs.c中实现函数体。于此同时，我们还需要在nanos-lite/src/loader.c中引入fs.h头文件。
\begin{lstlisting}[language = C++]
extern void ramdisk_read(void *buf, off_t offset, size_t len);
extern void ramdisk_write(const void *buf, off_t offset, size_t len);

size_t fs_fliesz(int fd) {
  assert(fd >= 0 && fd < NR_FILES);
  return file_table[fd].size;
}

off_t disk_offset(int fd){
  assert(fd >= 0 && fd < NR_FILES);
  return file_table[fd].disk_offset;
}

off_t get_open_offset(int fd){
  assert(fd >= 0 && fd < NR_FILES);
  return file_table[fd].open_offset;
}

void set_open_offset(int fd,off_t n){
  assert(fd >= 0 && fd < NR_FILES);
  assert(n >= 0);
  if(n > file_table[fd].size) {
    n = file_table[fd].size;
  }
  file_table[fd].open_offset = n;
} 

size_t fs_filesz(int fd){
  return file_table[fd].size;
}
\end{lstlisting}

根据文件名查找文件描述符 fd
\begin{lstlisting}[language = C++]
int fs_open(const char*filename, int flags, int mode) {
	for(int i = 0; i < NR_FILES; i++){
		if(strcmp(filename, file_table[i].name) == 0) {
			Log("success open:%d:%s",i,filename);
			return i;
		}
	}
	panic("this file not exist");
	return -1;
}
\end{lstlisting}

读取 fd 对应的文件。
\begin{lstlisting}[language = C++]
ssize_t fs_read(int fd, void *buf, size_t len){
  assert(fd >= 0 && fd < NR_FILES);
  if(fd < 3) {
    Log("arg invalid:fd<3");
    return 0;
  }
  int n = fs_fliesz(fd) - get_open_offset(fd);
  if(n > len) {
    n = len;
  }
  ramdisk_read(buf, disk_offset(fd) + get_open_offset(fd), n);
  set_open_offset(fd, get_open_offset(fd) + n);
  return n;
}
\end{lstlisting}

关闭文件
\begin{lstlisting}[language = C++]
int fs_close(int fd) {
  assert(fd >= 0 && fd < NR_FILES);
  return 0;
}
\end{lstlisting}


做完这些函数的定义后，我们要重新实现nanos-lite/src/loader.c中的loader函数。然后更改nanos-lite/src/main.c中的用户程序，让其加载text文件。
\begin{lstlisting}[language = C++]
uintptr_t loader(_Protect *as, const char *filename) {
  // TODO();
  // ramdisk_read(DEFAULT_ENTRY, 0, RAMDISK_SIZE);
  int fd = fs_open(filename, 0, 0);
  Log("filename=%s,fd=%d",filename,fd);
  fs_read(fd, DEFAULT_ENTRY, fs_filesz(fd));
  fs_close(fd);
  return (uintptr_t)DEFAULT_ENTRY;
}
\end{lstlisting}

\subsection{完整的文件系统实现}
我们在这里还需要实现fs\_write 和 fs\_seek，分别用来对 fd 对应的文件进行写操作和实现修改 fd 对应文件的 open\_offset的功能。

\begin{lstlisting}[language = C++]
ssize_t fs_write(int fd, void *buf, size_t len){
  assert(fd >= 0 && fd < NR_FILES);
  if(fd < 3) {
    Log("arg invalid:fd<3");
    return 0;
  }
  int n = fs_fliesz(fd) - get_open_offset(fd);
  if(n > len) {
    n = len;
  }
  ramdisk_write(buf, disk_offset(fd) + get_open_offset(fd), n);
  set_open_offset(fd, get_open_offset(fd) + n);
  return n;
}


off_t fs_lseek(int fd, off_t offset, int whence) {
  switch(whence) {
    case SEEK_SET:
      set_open_offset(fd, offset);
      return get_open_offset(fd);
    case SEEK_CUR:
      set_open_offset(fd, get_open_offset(fd) + offset);
      return get_open_offset(fd);
    case SEEK_END:
      set_open_offset(fd, fs_filesz(fd) + offset);
      return get_open_offset(fd);
    default:
      panic("Unhandled whence ID = %d", whence);
      return -1;
    }
}
\end{lstlisting}

然后，我们需要在nanos-lite/src/syscall.c文件中实现系统调用
\begin{lstlisting}[language = C++]
int sys_write(int fd, void *buf, size_t len) {
  if(fd == 1 || fd == 2) {
    char c;
    // Log("buffer:%s", (char*)buf);
    for(int i = 0; i < len; i++) {
      memcpy(&c ,buf + i, 1);
      _putc(c);
    }
    return len;
  }
  if(fd >= 3) {
    return fs_write(fd, buf, len);
  }
  Log("fd <= 0");
  return -1;			
}


int sys_open(const char *pathname){
    return fs_open(pathname, 0, 0);
}

int sys_read(int fd, void *buf,size_t len){
    return fs_read(fd, buf, len);
}

int sys_lseek(int fd, off_t offset, int whence) {
    return fs_lseek(fd, offset, whence);
}

int sys_close(int fd){
    return fs_close(fd);
}

_RegSet* do_syscall(_RegSet *r) {
  uintptr_t a[4];
  a[0] = SYSCALL_ARG1(r);
  a[1] = SYSCALL_ARG2(r);
  a[2] = SYSCALL_ARG3(r);
  a[3] = SYSCALL_ARG4(r);

  switch (a[0]) {
    case SYS_none: 
      SYSCALL_ARG1(r) = sys_none();
      break;
    case SYS_exit: 
      sys_exit(a[1]);
      break;
    case SYS_write:
      SYSCALL_ARG1(r) = sys_write(a[1], (void*)a[2], a[3]);
      break;
    case SYS_brk:
      SYSCALL_ARG1(r) = sys_brk(a[1]);
      break;
    case SYS_read:
      SYSCALL_ARG1(r) = sys_read(a[1],(void*)a[2],a[3]);
      break;
    case SYS_open:
      SYSCALL_ARG1(r) = sys_open((char*) a[1]);
      break;
    case SYS_close:
      SYSCALL_ARG1(r) = sys_close(a[1]);
      break;
    case SYS_lseek:
      SYSCALL_ARG1(r)=sys_lseek(a[1],a[2],a[3]);
      break;
    default: panic("Unhandled syscall ID = %d", a[0]);
  }

  return NULL;
}
\end{lstlisting}

修改 nanos.c 中的代码：
\begin{lstlisting}[language = C++]
int _open(const char *path, int flags, mode_t mode) {
  // _exit(SYS_open);
  return _syscall_(SYS_open, (uintptr_t)path, flags, mode);
}

int _write(int fd, void *buf, size_t count){
  return _syscall_(SYS_write, fd, (uintptr_t)buf, count);
}

int _read(int fd, void *buf, size_t count) {
  // _exit(SYS_read);
  return _syscall_(SYS_read, fd, (uintptr_t)buf, count);
}

int _close(int fd) {
  // _exit(SYS_close);
  return _syscall_(SYS_close, fd, 0, 0);
}

off_t _lseek(int fd, off_t offset, int whence) {
  // _exit(SYS_lseek);
  return _syscall_(SYS_lseek, fd, offset, whence);
}
\end{lstlisting}

\subsection{实验结果}
\begin{center}
  \includegraphics*[scale = 0.25]{pic/阶段二}
\end{center}

\color{red} 报错可能会迟到，但从不缺席，这里我们见bug总结/open\_offset和disk\_offset的区别

\normalcolor

\section{阶段三\ \ \ 一切皆文件}
在这一阶段，我们要把所有的东西都抽象成文件，不加以区分。

\subsection{把 VGA 显存抽象成文件}
/dev/fb将对应的数据写到VGA上，/proc/dispinfo包含了屏幕的相关信息，包含宽度和高度两个信息。我们所需要做的就是在读取文件、写入文件函数中，针对这两类文件进行重定向。
先在nexus-am/am/arch/x86-nemu/src/ioe.c中定义getScreen函数，返回屏幕大小信息
\begin{lstlisting}[language = C++]
void getScreen(int *width, int *height) {
  *width = _screen.width;
  *height = _screen.height;
} 
\end{lstlisting}

nanos-lite/src/fs.cwen文件中的init\_fs函数对文件记录表中的/dev/fb的大小进行初始化，IOE中定义的API在nexus-am目录下的am.h文件中，对应的函数在ioe.c文件中
\begin{lstlisting}[language = C++]
void init_fs() {
  // TODO: initialize the size of /dev/fb
  extern void getScreen(int *p_width, int *p_height);
  int width = 0;
  int height = 0;
  getScreen(&width, &height);
  file_table[FD_FB].size = width * height * sizeof(u_int32_t);
  Log("set FD_FB size = %d", file_table[FD_FB].size);
}
\end{lstlisting}

在 nanos-lite/src/device.c 实现fb\_write函数，来绘制屏幕上的像素点
\begin{lstlisting}[language = C++]
void fb_write(const void *buf, off_t offset, size_t len) {
  assert(offset % 4 == 0 && len % 4 == 0);
  int index, screen_x1, screen_y1, screen_y2;
  int width=0,height=0;
  getScreen(&width, &height);
  index=offset/4;
  screen_y1=index/width;
  screen_x1=index%width;

  index=(offset+len)/4;
  screen_y2=index/width;

  assert(screen_y2>=screen_y1);

  if(screen_y2==screen_y1)
  {
    _draw_rect(buf,screen_x1,screen_y1,len/4,1);
    return ;
  }

  int tempw=width-screen_x1;
  if(screen_y2-screen_y1==1)
  {
    _draw_rect(buf,screen_x1,screen_y1,tempw,1);
    _draw_rect(buf+tempw * 4 ,0,screen_y2,len/4-tempw,1);
    return ;
  }
  _draw_rect(buf, screen_x1, screen_y1, tempw, 1);
  int tempy = screen_y2 - screen_y1 - 1;
  _draw_rect(buf + tempw * 4, 0, screen_y1 + 1, width, tempy);
  _draw_rect(buf+tempw*4+tempy*width*4,0,screen_y2, len / 4 - tempw - tempy * width, 1);
}
\end{lstlisting}

然后我们在nanos-lite/src/device.c文件中添加init\_device函数将长宽信息按写入 dispinfo

\begin{lstlisting}[language = C++]
void init_device() {
  _ioe_init();

  // TODO: print the string to array `dispinfo` with the format
  // described in the Navy-apps convention
  int width = 0, height = 0;
  getScreen(&width, &height);
  sprintf(dispinfo, "WIDTH:%d\nHEIGHT:%d\n", width,height);
}

void dispinfo_read(void *buf, off_t offset, size_t len) {
  strncpy(buf, dispinfo + offset, len);
}
\end{lstlisting}

在nanos-lite/src/fs.c文件中补充fs\_write函数，

\begin{lstlisting}[language = C++]
extern void fb_write(const void *buf, off_t offset, size_t len);
ssize_t fs_write(int fd, void *buf, size_t len){
  assert(fd >= 0 && fd < NR_FILES);
  if(fd < 3 || fd == FD_DISPINFO) {
    Log("arg invalid:fd<3");
    return 0;
  }
  int n = fs_fliesz(fd) - get_open_offset(fd);
  if(n > len) {
    n = len;
  }
  if(fd == FD_FB){
    fb_write(buf, get_open_offset(fd), n);
  }
  else {
    ramdisk_write(buf, disk_offset(fd) + get_open_offset(fd), n);
  }
  set_open_offset(fd, get_open_offset(fd) + n);
  return n;
}
\end{lstlisting}
实验结果
\begin{center}
  \includegraphics*[scale = 0.2]{pic/5}
\end{center}
\color{red} 这里说的虽然轻描淡写，但遇到了迄今为止最大的问题，见bug总结/显存
\normalcolor

\subsection{把设备输入抽象成文件}
将时钟信息和按键信息抽象成文件/dev/events，并对其进行读取，用户程序可以从中一次读出一个输入事件。 首先在nanos­lite/src/device.c 中实现events\_read函数，将事件写入到buf中
\begin{lstlisting}[language = C++]
size_t events_read(void *buf, size_t len) {
  char buffer[40];
  int key = _read_key();
  int down = 0;
  if(key & 0x8000) {
      key ^= 0x8000;
      down = 1;
  }
  if(key != _KEY_NONE) {
      sprintf(buffer, "%s %s\n", down ? "kd": "ku", keyname[key]);
  }
  else {
      sprintf(buffer,"t %d\n", _uptime());
  }
  if(strlen(buffer) <= len) { 
    strncpy((char*)buf, buffer,strlen(buffer));
    return strlen(buffer);
  } 
  Log("strlen(event)>len, return 0");
  return 0;
}
\end{lstlisting}

在文件系统中添加对/dev/events 的支持:
\begin{lstlisting}[language = C++]
ssize_t fs_read(int fd, void *buf, size_t len){
  assert(fd >= 0 && fd < NR_FILES);
  if(fd < 3 || fd == FD_FB) {
    Log("arg invalid:fd<3");
    return 0;
  }
  if(fd == FD_EVENTS) {
    return events_read(buf, len);
  }
  int n = fs_fliesz(fd) - get_open_offset(fd);
  if(n > len) {
    n = len;
  }
  if(fd == FD_DISPINFO){
    dispinfo_read(buf, get_open_offset(fd), n);
  }
  else {
    ramdisk_read(buf, disk_offset(fd) + get_open_offset(fd), n);
  }
  set_open_offset(fd, get_open_offset(fd) + n);
  return n;
}
\end{lstlisting}

实验结果
\begin{center}
  \includegraphics*[scale = 0.3]{pic/6}
  \includegraphics*[scale = 0.3]{pic/7}
\end{center}

\subsection{运行仙剑奇侠传}
首先，我们在nemu/src/cpu/exec/data-mov.c文件中补充指令cwtl，这是一个AT\&A格式的符号扩展指令
\begin{lstlisting}[language = C++]
make_EHelper(cwtl) {
  if (decoding.is_operand_size_16) {
      rtl_lr_b(&t0, R_AX);
      rtl_sext(&t0, &t0, 1);
      rtl_sr_w(R_AX, &t0);
    } 
    else {
      rtl_lr_w(&t0, R_AX);
      rtl_sext(&t0, &t0, 2);
      rtl_sr_l(R_EAX, &t0);
    }
  print_asm(decoding.is_operand_size_16 ? "cbtw" : "cwtl");
}
\end{lstlisting}


然后我们将网上下载的输入放入navy-apps/fsimg/share/games/pal中，运行仙剑奇侠传
\begin{center}
  \includegraphics*[scale = 0.3]{pic/8}
  \includegraphics*[scale = 0.2]{pic/9}
  \includegraphics*[scale = 0.2]{pic/10}
  \includegraphics*[scale = 0.4]{pic/12}
\end{center}

卡的跟放ppt一样



















































































\section{bug总结}
这一部分，基本都是因为我们自己不听劝告，执意要使用64位系统，折腾gcc以及各种环境问题，导致了各种各样意想不到的问题。
\subsection{实现loader后出现段错误}
在我们最开始实现loader时，运行出现了段错误的问题，第一反应是肯定是代码书写有问题，心想坏了，这刚刚开始指定是以前代码的问题，顾花了一下午找之前代码中的问题，没找到，第一次破防。

\begin{center}
  \includegraphics*[scale=0.1]{pic/报错1}
\end{center}

然后想起来，可以查看反汇编代码，看出了端倪，生成了一堆没啥用的不知道是干啥的东西，导致程序过大越界了。意识到是因该是编译器的问题，上stackoverflow查找，在nano下的makefile 中加入如下参数，问题解决。
\begin{lstlisting}[language = bash]
OBJCOPY_FLAG = -S --remove-section .note.gnu.property --set-section-flags .bss=alloc,contents -O binary
\end{lstlisting}

\subsection{HAS ASYE宏开启}
在我们实现完popa和pusha并正确组织了trap frame之后，我们进行了运行测试，嘿嘿，出现了段错误。
\begin{center}
  \includegraphics*[scale = 0.3]{pic/报错2}
\end{center}
可以看到是因为gate\_addr的值大于了cpu.idtr.base + cpu.idtr.limit的值。我们利用Log进行输出，得到的结果比较出乎意料，cpu.idtr.base和cpu.idtr.limit的值都是0。总以为是哪里写错了，又从头到尾撸了一遍代码，没啥问题，最终发现是nanos-lite/src/main.c中的HAS ASY宏没打开，这意味着根本没有调用init\_irq()函数，也意味着没有调用位于 nexus-am/am/arch/x86-nemu/src/asye.c 中的\_asye\_init()函数，导致IDT根本都没初始化，加上了这个宏之后，错误解决了。

\subsection{CS指令}
这个地方，是我们实现Hello world运行的时候遇到的。按照指导书上的说法，我们做到这一步，嗨嗨嗨，不可能顺利的。果然，出现了如下如下的报错
\begin{center}
  \includegraphics*[scale = 0.25]{pic/报错3}
\end{center}
我觉得不合理，指令应该都实现了，无奈查找i386手册，发现这个应该是一个叫CS的指令（闻所未闻）。然后，我觉得这应该是64位系统的问题或者是ubuntu 20之类所带来的问题，在网上查阅资料后，感觉这个指令好像很endbr32差不多，没啥用，故在exe.c中设置为nop，怀着忐忑的心情又跑了一下，果然可以了，解决成功（希望以后不要爆雷）。

\subsection{open\_offset和disk\_offset的区别}
在我们实现了helloworld的需求之后，我们进行了运行测试，发现了如下的报错
\begin{center}
  \includegraphics*[scale = 0.25]{pic/报错5}
\end{center}

这个问题，本以为应该又是环境问题导致的，然后进行一顿找，试了好多种方法都没有解决。心灰意冷的时候开始对代码进行解决，发现，我们错将open\_offset全部当成了disk\_offset进行处理，这导致程序直接越界了。更改过后进行测试，程序无误。

\subsection{显存}
当我们实现显存的时候，我们兴冲冲的进行测试，然而发生了这样的问题。在我们运行程序的时候，出现了以下的问题：
\begin{center}
  \includegraphics*[scale = 0.25]{pic/baocuo}
\end{center}
因为我们用的是腾讯云服务器，图形化界面是通过vcn连接的，性能非常垃圾，所以我们理所应当的认为这是卡住了的问题，多试几次就好了，但是并没有什么用，这时候我意识到应该是代码处理问题，开始找代码中的错误。嗨嗨嗨，发现由于我的粗心，加载的并不是bin/bmptest，而是一个不知道是什么的乱七八糟的东西，将这个执行路径更改之后，本以为没啥问题了，谁知道真的噩梦才刚开始。

我们跑了一下代码，发现少了一个指令，查看i386手册，返现缺失的指令是movsb，听起来名字有些问题。我们竟一步查看手册，想要实现这个指令，发现需要额外的寄存器，ds和es。我们于是在cpu中添加了段寄存器ds和es，并修改了popa和pusha，本以为可以运行，结果又少了别因为64位高版本ubuntu导致的其他的指令。这时候心态已经崩掉了，在一点多准备换回32位的机器，因为电脑apple m1芯片的问题，还是只能租云服务器，于是租了一个阿里云，上传了环境。
\begin{center}
  \includegraphics*[scale = 0.3]{pic/fuq}
\end{center}
花了一个多小时，配置了可视化环境和基础的运行环境，然后发现虽然我的终端可以轻松连上远程服务器，但是vs code始终配不上，出现以下问题。
\begin{center}
  \includegraphics*[scale = 0.3]{pic/hhh}
\end{center}
最终我意识到vs code不支持ubuntu16这种老版本的ssh连接，心态有些不稳定了。然后啊，虽然新的环境的图形化界面装好了，但是官网提供的网页版vnc连接卡的不行，根本无法运行，按一下停好久好久，于是准备自己配vnc连接。反复试了x11vnc等一系列工具后，从最初的网络端口号呗阿里云屏蔽（在防火墙设置中可以进行设置打开，这是啥安全原因防止dns攻击之类的），到密码一直报错（密码存储的文件需要管理员权限才能读取，需要给予管理员权限）等等等，到最终非常好，直接黑屏了，网页版也打不开了，啥都不行了，心态彻底爆炸了。

这时候已经早上四点了，万念俱灰，想到了最后一个救命稻草，如果是编译出来 好多新的环境，那我试试换个低版本的gcc看看能不能结局。我下载了gcc7版本（没错仍然不是推荐的gcc5，ubuntu20貌似都装不了gcc5）并将默认的gcc路径进行了软连接，使用gcc7进行测试，貌似还是不行。正当想摆烂放弃的时候，我突然想到，有没有一种可能，是我没在最外层的环境中进行make clean，导致别的一些文件是用新版本的gcc编译的而导致错误，于是进行了clean后继续做最后一次尝试，成功了！！！屏幕上出现了logo，实验可以继续进行了！
\begin{center}
  \includegraphics*[scale=0.6]{pic/A}
\end{center}
虽然当时已经马上要到早上五点了，马上就该去做核酸大筛了，但是我还是好激动，甚至还发了一条朋友圈，虽然过程很艰难，但是历经好多弯路最终结局问题使程序顺利运行的感觉，真的是语言无法描述的。
\end{document}
